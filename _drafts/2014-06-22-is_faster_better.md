---
layout: post
category : Erlang
tagline:
tags : [Erlang, 效率, 闲话]
title: 【闲话】快总是好吗?
---

程序员都希望自己的程序跑得快一点, 一般来说, 程序就是由无数的函数调用组成的,
因此, 每个函数都返回得快, 整个程序就会更快. 对于Erlang网络服务器来说, 这总是对的吗?

看一下这段简单的代码:

```erlang
fib(1) -> 1;
fib(2) -> 1;
fib(N) -> fib(N-1) + fib(N-2).

do_fib() -> fib(30).
do_sleep() -> timer:sleep(100).
```

Fib是求菲波拉契数, 是个计算密集的函数. 在我的双核笔记本电脑上,
调用这个`do_fib`大约要耗时30毫秒. 而调用`do_sleep`耗时在代码中写明了, 是100毫秒.

嗯, 没错, `do_fib`返回得更快. 如果在我的笔记本电脑上运行两个网络服务器程序A和B,
A对于每个请求都执行一次`do_fib`后返回结果给客户端,
B对于每个请求都执行一次`do_sleep`后返回结果给客户端.
很容易想像, 假设代码只允许有一个Erlang进程的话, A每秒可以处理30个左右的请求,
B只能处理10个请求. 但是, 使用多进程的话, A每秒应付几十个请求CPU就会撑不住,
而B应付几百以至于更高的请求数都是没有问题的.

这是个比较极端的例子了, 不过可以说明, 并不是每个函数返回的速度快,
整个服务器的性能就高. 因为网络服务器是高并发的, 即使函数没有返回,
CPU是可以切换到别进程去干活, 而不会白白浪费时间.

对于网络服务器来说, 网络数据包收发就是类似于上面的`do_sleep`函数,
是等待密集而不是计算密集的. 如果只允许开启一个进程做网络服务,
要避免等待浪费CPU时间的做法就是所谓的异步, 把数据推给系统后马上返回,
干别的事情, 而不是傻等.

但用Erlang的话, 由于可以很高效开启很多的进程,
对每个连接开启一个进程进行处理是很轻松的. 这样子各个连接之间互不影响.
假如有某个客户连接接收慢, 包发不出去卡住了, 这只会影响他自己, 而不会影响其他人.
等待期间, Erlang虚拟机会把CPU分配给其他进程使用, 不会浪费.

一般来说, 同步的逻辑比异步的容易写, 一件事情做完再做下一件事, 十分的清晰明了,
在Erlang中, 每个网络进程只需要按部就班地把数据发出去,
像CPU和IO复用之类麻烦事, 交给Erlang的多进程机制去做就好了.

不过, 改进算法总是好的, 上面的fib效率不忍直视了, 改成尾递归版本就快多了:

```erlang
fib2(N) ->
    fib2(N, 1, 1).

fib2(I, _, FN) when I =< 2->
    FN;
fib2(I, F1, FN) ->
    fib2(I-1, FN, FN+F1).
```

这个算fib2(30)在我的机上只需要1微秒, 换言之1秒钟可以执行100万次, 不过可读性就呵呵了...
